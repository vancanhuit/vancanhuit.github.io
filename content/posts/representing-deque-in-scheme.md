+++ 
draft = true
date = 2024-07-27T10:50:39+07:00
title = "Representing deque in Scheme"
+++

[https://sarabander.github.io/sicp/html/3_002e3.xhtml#g_t3_002e3_002e2](https://sarabander.github.io/sicp/html/3_002e3.xhtml#g_t3_002e3_002e2)

```scheme
(define (make-node value)
    (let ((node (list value
                      '() ; previous node
                      '() ; next node
                      )))
      (define (set-value v)
        (set-car! node v))
      (define (set-next-ptr p)
        (set-car! (cddr node) p))
      (define (set-prev-ptr p)
        (set-car! (cdr node) p))
      (define (dispatch m)
        (cond ((eq? m 'value) (car node))
              ((eq? m 'set-value) set-value)
              ((eq? m 'set-next-ptr) set-next-ptr)
              ((eq? m 'set-prev-ptr) set-prev-ptr)
              ((eq? m 'next-ptr) (caddr node))
              ((eq? m 'prev-ptr) (cadr node))
              (else (error "Operation is not supported: " m))))
      dispatch))

(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty?)
      (or (null? front-ptr)
          (null? rear-ptr)))
    (define (front)
      (if (empty?)
          (error "FRONT called with an empty queue.")
          front-ptr))
    (define (rear)
      (if (empty?)
          (error "REAR called with an empty queue")
          rear-ptr))
    (define (front-insert item)
      (let ((node (make-node item)))
        (cond ((empty?)
               (set! front-ptr node)
               (set! rear-ptr node))
              (else
               ((node 'set-next-ptr) front-ptr)
               ((front-ptr 'set-prev-ptr) node)
               (set! front-ptr node)))))
    (define (rear-insert item)
      (let ((node (make-node item)))
        (cond ((empty?)
               (set! rear-ptr node)
               (set! front-ptr node))
              (else
               ((node 'set-prev-ptr) rear-ptr)
               ((rear-ptr 'set-next-ptr) node)
               (set! rear-ptr node)))))
    (define (front-delete)
      (cond ((empty?)
             (error "FRONT-DELETE called with an empty queue."))
             (else
              (set! front-ptr (front-ptr 'next-ptr))
              (if (not (empty?))
                  ((front-ptr 'set-prev-ptr) '())))))
    (define (rear-delete)
      (cond ((empty?)
             (error "REAR-DELETE called with an empty queue. "))
            (else
             (set! rear-ptr (rear-ptr 'prev-ptr))
             (if (not (empty?))
                 ((rear-ptr 'set-next-ptr) '())))))
    (define (deque->list ptr)
      (if (null? ptr)
          '()
          (cons (ptr 'value)
                (deque->list (ptr 'next-ptr)))))
    (define (dispatch m)
      (cond ((eq? m 'front) (front))
            ((eq? m 'rear) (rear))
            ((eq? m 'empty?) (empty?))
            ((eq? m 'front-insert) front-insert)
            ((eq? m 'rear-insert) rear-insert)
            ((eq? m 'front-delete) (front-delete))
            ((eq? m 'rear-delete) (rear-delete))
            ((eq? m 'print) (deque->list front-ptr))
            (else (error "Operation is not supported: " m))))
    dispatch))

(define q (make-deque))
(q 'empty?)
(q 'print)
((q 'front-insert) 'a)
((q 'front-insert) 'b)
((q 'rear-insert) 'c)
((q 'rear-insert) 'd)
(q 'empty?)
(q 'print)
((q 'front) 'value)
((q 'rear) 'value)
(((q 'front) 'next-ptr) 'value)
((q 'front) 'prev-ptr)
(((q 'rear) 'prev-ptr) 'value)
((q 'rear) 'next-ptr)
(q 'front-delete)
(q 'print)
(q 'rear-delete)
(q 'print)
(q 'rear-delete)
(q 'print)
(q 'front-delete)
(q 'empty?)
(q 'print)
```
